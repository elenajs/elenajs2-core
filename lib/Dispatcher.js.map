{"version":3,"sources":["../src/Dispatcher.js"],"names":["require","path","url","HttpStatusError","Dispatcher","_dispatchers","pathKey","dispatcher","name","pathArray","request","responseFilters","_requestFilter","_responseFilter","push","currDispatcher","shift","replace","isEligible","_selectDispatcher","response","responseServed","once","parse","pathname","split","slice","render","join","data","forEach","filter","requst","end","pipe","afterPathname","_renderer","cb","module","exports","makeDispatcher","params","renderer","remderer","requestFilter","responseFilter"],"mappings":"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","file":"Dispatcher.js","sourcesContent":["\"use strict\";\nrequire('gulp-polyfill');\n\nconst path = require('path'),\n    url = require('url'),\n    HttpStatusError = require('./HttpStatusError.js');\n\n\n\nclass Dispatcher {\n\n    constructor() {\n        this._dispatchers = {};\n    }\n\n    set renderer(cb) {\n        this._renderer = cb;\n    }\n\n    set requestFilter(cb) {\n        this._requestFilter = cb;\n    }\n\n    set responseFilter(cb) {\n        this._responseFilter = cb;\n    }\n\n    addDispatcher(pathKey, dispatcher) {\n        this._dispatchers[pathKey] = dispatcher;\n        return this;\n    }\n\n    toString() {\n        let name = 'Dispatcher';\n        return `[object ${name}]`;\n    }\n\n\n    async _selectDispatcher(pathArray, request, responseFilters) {\n        if (this._requestFilter) {\n            await this._requestFilter(request);\n        }\n        if (this._responseFilter) {\n            responseFilters.push(this._responseFilter);\n        }\n        let currDispatcher = this._dispatchers[pathArray.shift().replace(/\\..*$/,'')];\n        return (currDispatcher && await currDispatcher.isEligible(request) && currDispatcher._selectDispatcher(pathArray, request, responseFilters)) || this;\n    }\n\n    async dispatch(request, response) {\n        let responseServed = false;\n        response.once('finish', () => {responseServed=true;});\n        let pathArray = url.parse(request.url).pathname.split('/');\n\n        let responseFilters = [],\n            dispatcher = this._selectDispatcher(pathArray.slice(1), request, responseFilters);\n\n        let data = await dispatcher.render(request, response, pathArray.join('/'));\n        responseFilters.forEach((filter) => filter(requst, response));\n        if (!responseServed) {\n            if (typeof data === 'string') {\n                response.end(data);\n            } else {\n                data.pipe(response);\n            }\n        }\n\n    }\n\n    async render(request, response, afterPathname) {\n        if (!this._renderer) {\n            throw new HttpStatusError(501);\n        } else {\n            return this._renderer(request, response, afterPathname);\n        }\n    }\n\n}\n\nmodule.exports = Dispatcher;\n\n/**\n * This function create a dipartcher. A dispatcher is routing object that reads incoming http requests and\n * writes to an http response.\n * @param params. Configuration object whose attributes are:\n *  - renderer::<function(request::http.IncomingMessage, response::http.ServerResponse, afterPathname::string)> Async callback returning a string or a readable stream that will be rendered to an http response.\n *    afterPathName is the url pathname minus the dispatcher routing path\n *  - requestFilter::<function(request::http.IncomingMessage)> Async Callback called every time the dispatcher is traversed.\n *    Request filter is the ideal place to put authorization to protected resources.\n *  - responseFilter::<function(request::http.IncomingMessage,response::http.ServerResponse)> Like params.requestFilter but called after rendering.\n * @returns {Dispatcher}\n */\nmodule.exports.makeDispatcher = function (params) {\n    let dispatcher = new Dispatcher();\n    dispatcher.renderer = params.remderer;\n    dispatcher.requestFilter = params.requestFilter;\n    dispatcher.responseFilter = params.responseFilter;\n    return dispatcher;\n};\n"]}